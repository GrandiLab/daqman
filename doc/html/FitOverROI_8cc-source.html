<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>daqman: analysis/src/FitOverROI.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_45112185e8b2b20582771867bff7ed01.html">analysis</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_0e1017bd2214db0b340afa834279e37e.html">src</a></div>
<h1>FitOverROI.cc</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include "<a class="code" href="FitOverROI_8hh.html">FitOverROI.hh</a>"</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include "TMath.h"</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include "TROOT.h"</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include "TFitResult.h"</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include "TSpectrum.h"</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "TTree.h"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "TFile.h"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "TF1.h"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "TCanvas.h"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "TPad.h"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "TLine.h"</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include "TAxis.h"</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="preprocessor">#include "TList.h"</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include "TCut.h"</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;numeric&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include "TMatrixDSym.h"</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include "TGraph.h"</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="keyword">using namespace </span>std;
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#define HISTOGRAMWIDTH 7</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#define NPEAKS 7</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="preprocessor">#define mCON params[CONSTANT]</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#define mLAM params[LAMBDA]</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define mMEAN params[MEAN]</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#define mSIG params[SIGMA]</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#define mAMP params[AMP_E]</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#define mPE params[P_E]</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#define mSHT params[SHOTNOISE]</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#define mPDM params[PEDMEAN]</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="keyword">const</span> <span class="keywordtype">char</span>* names[] = {<span class="stringliteral">"CONSTANT"</span>,<span class="stringliteral">"LAMBDA"</span>, <span class="stringliteral">"SPE_MEAN"</span>, <span class="stringliteral">"SPE_SIGMA"</span>, <span class="stringliteral">"AMP_E"</span>, <span class="stringliteral">"P_E"</span>, <span class="stringliteral">"SHOTNOISE"</span> ,<span class="stringliteral">"PEDMEAN"</span>,<span class="stringliteral">"NPAR"</span>};
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 
<a name="l00048"></a><a class="code" href="namespaceFitOverROI.html#782b45be6657463b227de4f1ec72f2f3">00048</a> Double_t <a class="code" href="namespaceFitOverROI.html#782b45be6657463b227de4f1ec72f2f3">FitOverROI::response_0</a>(Double_t* x, Double_t* params) 
<a name="l00049"></a>00049 {
<a name="l00050"></a>00050     <span class="keywordtype">double</span> y = x[0] - mPDM;
<a name="l00051"></a>00051     <span class="keywordflow">return</span> mCON*TMath::Poisson(0,mLAM)*TMath::Gaus(y, 0, mSHT, <span class="keyword">true</span>);
<a name="l00052"></a>00052 }
<a name="l00053"></a>00053 
<a name="l00054"></a><a class="code" href="namespaceFitOverROI.html#a9ef60648d7d520d4dd4a367a37a05f1">00054</a> Double_t <a class="code" href="namespaceFitOverROI.html#a9ef60648d7d520d4dd4a367a37a05f1">FitOverROI::background_func</a>(Double_t* x, Double_t* params)
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056     <span class="keywordtype">double</span> y = x[0] - mPDM;
<a name="l00057"></a>00057 
<a name="l00058"></a>00058     <span class="comment">//mathematica version (my own convolution)</span>
<a name="l00059"></a>00059     <span class="keywordtype">double</span> exp_term=(TMath::Power(TMath::E(),(-2*mAMP*y + mSHT*mSHT)/
<a name="l00060"></a>00060                                   (2.*mAMP*mAMP))*mPE*
<a name="l00061"></a>00061                      (1 + TMath::Erf(((mAMP*y)/mSHT - mSHT)/(sqrt(2)*mAMP))))/
<a name="l00062"></a>00062         (2.*mAMP);
<a name="l00063"></a>00063     <span class="keywordflow">return</span> mCON*TMath::Poisson(1,mLAM)*exp_term;
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00066"></a><a class="code" href="namespaceFitOverROI.html#cbf4b918771039339f9acb5af44ecbfb">00066</a> Double_t <a class="code" href="namespaceFitOverROI.html#cbf4b918771039339f9acb5af44ecbfb">FitOverROI::gauss_func</a>(Double_t* x, Double_t* params)
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068     <span class="keywordtype">double</span> y = x[0] - mPDM;
<a name="l00069"></a>00069     <span class="keywordtype">double</span> sigma_1=sqrt(mSHT*mSHT + mSIG*mSIG); 
<a name="l00070"></a>00070         
<a name="l00071"></a>00071     <span class="keywordtype">double</span> gauss_term= (1-mPE)*(TMath::Power(TMath::E(), - (mMEAN-y)*(mMEAN-y)/(2*sigma_1*sigma_1)) *
<a name="l00072"></a>00072                                 (1 + TMath::Erf((mMEAN*mSHT*mSHT + mSIG*mSIG*y)/(sqrt(2) * mSIG*mSHT *sigma_1))) /
<a name="l00073"></a>00073                                 (sqrt(2*TMath::Pi())*sigma_1 * (1+ TMath::Erf(mMEAN/(sqrt(2)*mSIG)))));
<a name="l00074"></a>00074         
<a name="l00075"></a>00075         
<a name="l00076"></a>00076     <span class="keywordtype">double</span> response=mCON*TMath::Poisson(1,mLAM)*gauss_term;
<a name="l00077"></a>00077     <span class="keywordflow">return</span> response;
<a name="l00078"></a>00078 }  
<a name="l00079"></a>00079   
<a name="l00080"></a><a class="code" href="namespaceFitOverROI.html#6f7d5a1547b47c190c8ed6f4a759ebd6">00080</a> Double_t <a class="code" href="namespaceFitOverROI.html#6f7d5a1547b47c190c8ed6f4a759ebd6">FitOverROI::response_1</a>(Double_t* x, Double_t* params)
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082     <span class="keywordtype">double</span> exp_term= <a class="code" href="namespaceFitOverROI.html#a9ef60648d7d520d4dd4a367a37a05f1">background_func</a>(x, params);
<a name="l00083"></a>00083         
<a name="l00084"></a>00084     <span class="keywordtype">double</span> gauss_term= <a class="code" href="namespaceFitOverROI.html#cbf4b918771039339f9acb5af44ecbfb">gauss_func</a>(x, params);
<a name="l00085"></a>00085         
<a name="l00086"></a>00086         
<a name="l00087"></a>00087     <span class="keywordtype">double</span> response=gauss_term+exp_term;
<a name="l00088"></a>00088     <span class="keywordflow">return</span> response;
<a name="l00089"></a>00089 }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 
<a name="l00092"></a><a class="code" href="namespaceFitOverROI.html#8aa4e710418f691c677a8f843403d2a0">00092</a> Double_t <a class="code" href="namespaceFitOverROI.html#8aa4e710418f691c677a8f843403d2a0">FitOverROI::response_2</a>(Double_t* x, Double_t* params)
<a name="l00093"></a>00093 {
<a name="l00094"></a>00094     <span class="keywordtype">double</span> y = x[0] - mPDM;
<a name="l00095"></a>00095     <span class="keywordtype">double</span> response=((TMath::Power(TMath::E(),(-2*mAMP*y + TMath::Power(mSHT,2))/
<a name="l00096"></a>00096                                    (2.*TMath::Power(mAMP,2)))*mPE*mPE*
<a name="l00097"></a>00097                       (mAMP*y - TMath::Power(mSHT,2)))/TMath::Power(mAMP,3) + 
<a name="l00098"></a>00098                      (2*TMath::Power(-1 + mPE,2)*sqrt(2/TMath::Pi()))/
<a name="l00099"></a>00099                      (TMath::Power(TMath::E(),TMath::Power(-2*mMEAN + y,2)/
<a name="l00100"></a>00100                                    (2.*(TMath::Power(mSHT,2) + 
<a name="l00101"></a>00101                                         2*TMath::Power(mSIG,2))))*mSHT*
<a name="l00102"></a>00102                       sqrt(2/TMath::Power(mSHT,2) + TMath::Power(mSIG,-2))*
<a name="l00103"></a>00103                       mSIG*TMath::Power(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG)),2)) 
<a name="l00104"></a>00104                      + (2*TMath::Power(TMath::E(),
<a name="l00105"></a>00105                                        (2*mAMP*mMEAN - 2*mAMP*y + TMath::Power(mSHT,2) + 
<a name="l00106"></a>00106                                         TMath::Power(mSIG,2))/(2.*TMath::Power(mAMP,2)))*
<a name="l00107"></a>00107                         (-1 + mPE)*mPE*
<a name="l00108"></a>00108                         (-1 + TMath::Erf((mAMP*(mMEAN - y) + 
<a name="l00109"></a>00109                                           TMath::Power(mSHT,2) + TMath::Power(mSIG,2))/
<a name="l00110"></a>00110                                          (mAMP*sqrt(2*TMath::Power(mSHT,2) + 
<a name="l00111"></a>00111                                                     2*TMath::Power(mSIG,2))))))
<a name="l00112"></a>00112                      /(mAMP*(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG)))));
<a name="l00113"></a>00113     
<a name="l00114"></a>00114     <span class="keywordflow">return</span> TMath::Poisson(2,mLAM)*mCON*response;
<a name="l00115"></a>00115     
<a name="l00116"></a>00116       <span class="comment">/*double sigma_1=sqrt(mSHT*mSHT + mSIG*mSIG);     </span>
<a name="l00117"></a>00117 <span class="comment">      </span>
<a name="l00118"></a>00118 <span class="comment">      double response= TMath::Poisson(2,mLAM)*(mPE*mPE*y/(mAMP*mAMP) * TMath::Power(TMath::E(), -y/mAMP)+ </span>
<a name="l00119"></a>00119 <span class="comment">      2 * (1-mPE)*mPE/(sqrt(2*TMath::Pi())*sigma_1) * TMath::Power(TMath::E(), -0.5*(y-mMEAN-mAMP)*(y-mMEAN-mAMP)/(sigma_1*sigma_1)) + </span>
<a name="l00120"></a>00120 <span class="comment">      (1-mPE)*(1-mPE)/(2 *sqrt(TMath::Pi())*sigma_1) *TMath::Power(TMath::E(),-0.5 *(y- 2*mMEAN)*(y- 2*mMEAN)/(sigma_1 * sigma_1 *2)));</span>
<a name="l00121"></a>00121 <span class="comment">      return mCON*response;*/</span>
<a name="l00122"></a>00122 }
<a name="l00123"></a>00123         
<a name="l00124"></a><a class="code" href="namespaceFitOverROI.html#cd8556cb95c7193b9f4a2f5dac107c44">00124</a> Double_t <a class="code" href="namespaceFitOverROI.html#cd8556cb95c7193b9f4a2f5dac107c44">FitOverROI::m_n</a>(<span class="keyword">const</span> Double_t* params)
<a name="l00125"></a>00125 {
<a name="l00126"></a>00126     <span class="keywordflow">return</span> mMEAN + mAMP*mPE - mMEAN*mPE + 
<a name="l00127"></a>00127         (sqrt(2/TMath::Pi())*mSIG*
<a name="l00128"></a>00128          (1/(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG))) + 
<a name="l00129"></a>00129           mPE/(-2 + TMath::Erfc(mMEAN/(sqrt(2)*mSIG)))))/
<a name="l00130"></a>00130         TMath::Power(TMath::E(),TMath::Power(mMEAN,2)/(2.*TMath::Power(mSIG,2)));
<a name="l00131"></a>00131 }
<a name="l00132"></a>00132 
<a name="l00133"></a><a class="code" href="namespaceFitOverROI.html#7146b6447b232829fe65c0c222d1a649">00133</a> Double_t <a class="code" href="namespaceFitOverROI.html#7146b6447b232829fe65c0c222d1a649">FitOverROI::sigma_n</a>(<span class="keyword">const</span>  Double_t* params)
<a name="l00134"></a>00134 {
<a name="l00135"></a>00135     <span class="keywordflow">return</span> sqrt(-(TMath::Power(mMEAN,2)*(-1 + mPE)) + 
<a name="l00136"></a>00136                 2*TMath::Power(mAMP,2)*mPE  - 
<a name="l00137"></a>00137                 (-1 + mPE)*TMath::Power(mSIG,2) - 
<a name="l00138"></a>00138                 TMath::Power(mMEAN + mAMP*mPE - mMEAN*mPE + 
<a name="l00139"></a>00139                              (sqrt(2/TMath::Pi())*mSIG*
<a name="l00140"></a>00140                               (1/(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG))) + 
<a name="l00141"></a>00141                                mPE/(-2 + TMath::Erfc(mMEAN/(sqrt(2)*mSIG)))
<a name="l00142"></a>00142                                   ))/
<a name="l00143"></a>00143                              TMath::Power(TMath::E(),TMath::Power(mMEAN,2)/
<a name="l00144"></a>00144                                           (2.*TMath::Power(mSIG,2))),2) + 
<a name="l00145"></a>00145                 (mMEAN*sqrt(2/TMath::Pi())*mSIG*
<a name="l00146"></a>00146                  (1/(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG))) + 
<a name="l00147"></a>00147                   mPE/(-2 + TMath::Erfc(mMEAN/(sqrt(2)*mSIG)))))
<a name="l00148"></a>00148                 /TMath::Power(TMath::E(),TMath::Power(mMEAN,2)/
<a name="l00149"></a>00149                               (2.*TMath::Power(mSIG,2))));
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151            
<a name="l00152"></a><a class="code" href="namespaceFitOverROI.html#7700a1594ba5fda92fcbabed6d06087b">00152</a> Double_t <a class="code" href="namespaceFitOverROI.html#7700a1594ba5fda92fcbabed6d06087b">FitOverROI::response_multi</a>(Double_t* x, Double_t* params)
<a name="l00153"></a>00153 {       
<a name="l00154"></a>00154     <span class="keywordtype">double</span> y = x[0] - mPDM;
<a name="l00155"></a>00155         
<a name="l00156"></a>00156                 
<a name="l00157"></a>00157     <span class="keywordtype">double</span> response=0;
<a name="l00158"></a>00158         
<a name="l00159"></a>00159     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=3; i&lt;=NPEAKS; i++)
<a name="l00160"></a>00160     {
<a name="l00161"></a>00161         response += TMath::Poisson(i,mLAM) *TMath::Gaus(y,<a class="code" href="namespaceFitOverROI.html#cd8556cb95c7193b9f4a2f5dac107c44">m_n</a>(params)*i,sqrt(i*<a class="code" href="namespaceFitOverROI.html#7146b6447b232829fe65c0c222d1a649">sigma_n</a>(params)*<a class="code" href="namespaceFitOverROI.html#7146b6447b232829fe65c0c222d1a649">sigma_n</a>(params)+TMath::Power(mSHT,2)),<span class="keyword">true</span>);
<a name="l00162"></a>00162     }
<a name="l00163"></a>00163     <span class="keywordflow">return</span> mCON*response;
<a name="l00164"></a>00164 }       
<a name="l00165"></a>00165 
<a name="l00166"></a><a class="code" href="namespaceFitOverROI.html#cf1aff5259a404c02778a776e341515f">00166</a> Double_t <a class="code" href="namespaceFitOverROI.html#cf1aff5259a404c02778a776e341515f">FitOverROI::SPEFunc</a>(Double_t* x, Double_t* params)
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168     <span class="keywordtype">double</span> sig = (<a class="code" href="namespaceFitOverROI.html#782b45be6657463b227de4f1ec72f2f3">response_0</a>(x, params)+<a class="code" href="namespaceFitOverROI.html#6f7d5a1547b47c190c8ed6f4a759ebd6">response_1</a>(x,params)+<a class="code" href="namespaceFitOverROI.html#8aa4e710418f691c677a8f843403d2a0">response_2</a>(x,params)+<a class="code" href="namespaceFitOverROI.html#7700a1594ba5fda92fcbabed6d06087b">response_multi</a>(x,params));    
<a name="l00169"></a>00169     <span class="comment">/*double fixerparams[] = {mCON, 0.00143997, 83.9085, 29.0772, 149.998, 0.704112 , mSHT };</span>
<a name="l00170"></a>00170 <span class="comment">      double base= (response_1(x,fixerparams)+response_2(x,fixerparams)+response_multi(x,fixerparams));</span>
<a name="l00171"></a>00171 <span class="comment">      return sig*(TMath::Poisson(0,0.00143997))+base;*/</span>
<a name="l00172"></a>00172     <span class="keywordflow">return</span> sig;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 }
<a name="l00175"></a>00175 
<a name="l00176"></a><a class="code" href="namespaceFitOverROI.html#92818864b2acc85695cf700e5c99a8f8">00176</a> TFitResultPtr <a class="code" href="namespaceFitOverROI.html#2baa97145dc2dd323492ea8c114efaa6">FitOverROI::FitSPE</a>(<a class="code" href="classFitTH1F.html">FitTH1F</a>* spe, <a class="code" href="classChanFitSettings.html">ChanFitSettings</a>&amp; CFS, <span class="keywordtype">int</span> ntriggers,
<a name="l00177"></a>00177                                  <span class="keywordtype">bool</span> allow_bg,
<a name="l00178"></a>00178                                  <span class="keywordtype">bool</span> force_old)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180     
<a name="l00181"></a>00181     TF1* spefunc = (TF1*)gROOT-&gt;GetFunction(<span class="stringliteral">"spefunc"</span>);
<a name="l00182"></a>00182     <span class="keywordtype">int</span> nEvtsInRange = (int)spe-&gt;Integral(0,spe-&gt;GetNbinsX()+1,<span class="stringliteral">"width"</span>);
<a name="l00183"></a>00183         
<a name="l00184"></a>00184     spe-&gt;GetXaxis()-&gt;SetRangeUser(CFS.<a class="code" href="classChanFitSettings.html#cfef76ebcb304b97f12b5e391c4e552c">range_min</a>, CFS.<a class="code" href="classChanFitSettings.html#905700665734466c9c4c540d90896245">range_max</a>);
<a name="l00185"></a>00185         
<a name="l00186"></a>00186     <span class="keywordtype">double</span> fitmin, fitmax;
<a name="l00187"></a>00187     fitmin = spe-&gt;GetBinLowEdge(spe-&gt;GetXaxis()-&gt;GetFirst());
<a name="l00188"></a>00188     fitmax = 0;
<a name="l00189"></a>00189     <span class="comment">//find the last non-zero bin</span>
<a name="l00190"></a>00190     <span class="keywordtype">int</span> bin = spe-&gt;GetXaxis()-&gt;GetLast();
<a name="l00191"></a>00191     <span class="comment">//bin = spe-&gt;GetNbinsX()+1;</span>
<a name="l00192"></a>00192                 
<a name="l00193"></a>00193     <span class="keywordflow">while</span>(spe-&gt;GetBinContent(bin) == 0) {bin--;}
<a name="l00194"></a>00194     fitmax = spe-&gt;GetBinLowEdge(bin);
<a name="l00195"></a>00195     fitmax = fitmax*1; 
<a name="l00196"></a>00196 
<a name="l00197"></a>00197     <span class="comment">//Pedestal centering</span>
<a name="l00198"></a>00198         
<a name="l00199"></a>00199     Double_t pedmean = CFS.<a class="code" href="classChanFitSettings.html#12efc0df68484680f95ab5e6aaaba1cb">pedmean_min_bound</a>;
<a name="l00200"></a>00200     <span class="keywordflow">if</span>(fitmin&lt;0 &amp;&amp; !force_old &amp;&amp; (max(fitmin,CFS.<a class="code" href="classChanFitSettings.html#72eedcd8e96f683223220fadb6f6a5f8">pedrange_min</a>)&lt; min(CFS.<a class="code" href="classChanFitSettings.html#3faabd4403810b2b821914716019e76b">pedrange_max</a>,fitmax)))
<a name="l00201"></a>00201     {
<a name="l00202"></a>00202         spe-&gt;GetXaxis()-&gt;SetRangeUser(max(fitmin,CFS.<a class="code" href="classChanFitSettings.html#72eedcd8e96f683223220fadb6f6a5f8">pedrange_min</a>), min(CFS.<a class="code" href="classChanFitSettings.html#3faabd4403810b2b821914716019e76b">pedrange_max</a>,fitmax));
<a name="l00203"></a>00203         std::cout&lt;&lt;<span class="stringliteral">"Fitting pedestal in range ["</span>&lt;&lt;max(fitmin,CFS.<a class="code" href="classChanFitSettings.html#72eedcd8e96f683223220fadb6f6a5f8">pedrange_min</a>)&lt;&lt;<span class="stringliteral">", "</span>&lt;&lt;min(fitmax,CFS.<a class="code" href="classChanFitSettings.html#3faabd4403810b2b821914716019e76b">pedrange_max</a>)&lt;&lt;<span class="stringliteral">"]"</span>&lt;&lt;std::endl;
<a name="l00204"></a>00204         TFitResultPtr pedfit = spe-&gt;Fit(<span class="stringliteral">"gaus"</span>,<span class="stringliteral">"QMIS"</span>);
<a name="l00205"></a>00205         <span class="keywordflow">if</span>(pedfit.Get())
<a name="l00206"></a>00206         {
<a name="l00207"></a>00207             pedmean = pedfit-&gt;Value(1);
<a name="l00208"></a>00208         }
<a name="l00209"></a>00209         <span class="keywordflow">else</span>{pedmean=0;}
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211     <span class="keywordflow">if</span>(force_old)
<a name="l00212"></a>00212     {
<a name="l00213"></a>00213         pedmean=spefunc-&gt;GetParameter(PEDMEAN);
<a name="l00214"></a>00214     }
<a name="l00215"></a>00215         
<a name="l00216"></a>00216     <span class="keywordtype">double</span> params[NPAR];
<a name="l00217"></a>00217     <span class="comment">//find the likely place for the single p.e. peak</span>
<a name="l00218"></a>00218     bin = spe-&gt;FindBin(0);
<a name="l00219"></a>00219     <span class="comment">//params[SHOTNOISE] = FindExtremum(bin, spe, FORWARD, MINIMUM)/3.;</span>
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 
<a name="l00222"></a>00222     <span class="keywordflow">if</span>(!force_old || !spefunc)
<a name="l00223"></a>00223     {
<a name="l00224"></a>00224         params[SHOTNOISE] = CFS.<a class="code" href="classChanFitSettings.html#8ef9c10ce0b2dbd602816f102e9f1f07">shotnoise_start_value</a>;
<a name="l00225"></a>00225         params[MEAN] = CFS.<a class="code" href="classChanFitSettings.html#0ee72a825c37842b082c86cbb444541a">mean_start_value</a>;
<a name="l00226"></a>00226         params[SIGMA] = CFS.<a class="code" href="classChanFitSettings.html#4c5c172f631bfef60aa461954a3d7385">sigma_start_value</a>;
<a name="l00227"></a>00227         params[LAMBDA] = CFS.<a class="code" href="classChanFitSettings.html#2942b54d5b895ab3f7f14d02fb9938f8">lambda_start_value</a>;
<a name="l00228"></a>00228         <span class="keywordflow">if</span>(CFS.<a class="code" href="classChanFitSettings.html#16147a3180ed8c1fe11e540b306cef07">constant_start_value</a>)
<a name="l00229"></a>00229         { 
<a name="l00230"></a>00230             params[CONSTANT] = nEvtsInRange;
<a name="l00231"></a>00231         } 
<a name="l00232"></a>00232         <span class="keywordflow">else</span>
<a name="l00233"></a>00233         {  
<a name="l00234"></a>00234             params[CONSTANT] = CFS.<a class="code" href="classChanFitSettings.html#16147a3180ed8c1fe11e540b306cef07">constant_start_value</a>;
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236         params[AMP_E] = CFS.<a class="code" href="classChanFitSettings.html#cbcaaf46fbff8bb0f71db1f5f7ba8e49">amp_E_start_value</a>;
<a name="l00237"></a>00237         params[P_E] = CFS.<a class="code" href="classChanFitSettings.html#f8e45beb9ae301d7a5b58d0b539e7a0b">p_E_start_value</a>;  
<a name="l00238"></a>00238                 
<a name="l00239"></a>00239         spefunc = <span class="keyword">new</span> TF1(<span class="stringliteral">"spefunc"</span>, <a class="code" href="namespaceFitOverROI.html#cf1aff5259a404c02778a776e341515f">SPEFunc</a>, fitmin, fitmax, NPAR);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241         spefunc-&gt;SetParameters(params);
<a name="l00242"></a>00242         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;NPAR; i++)
<a name="l00243"></a>00243             spefunc-&gt;SetParName(i, names[i]);
<a name="l00244"></a>00244         <span class="comment">//spefunc-&gt;SetParLimits(CONSTANT, 0 , params[CONSTANT]);</span>
<a name="l00245"></a>00245         <span class="comment">//DIVOT</span>
<a name="l00246"></a>00246         spefunc-&gt;SetParLimits(LAMBDA, CFS.<a class="code" href="classChanFitSettings.html#fb4a68ddb699fcb45a1b783aff08f3b7">lambda_min_bound</a>, CFS.<a class="code" href="classChanFitSettings.html#c5cd0430cb857c796012a160f0eb84aa">lambda_max_bound</a>);
<a name="l00247"></a>00247         spefunc-&gt;SetParLimits(MEAN, CFS.<a class="code" href="classChanFitSettings.html#d97a68b39ea9aeef5e93c23a3feb2ebb">mean_min_bound</a>, CFS.<a class="code" href="classChanFitSettings.html#dc9bb60abc2cdca49ac8898ef74f8d7d">mean_max_bound</a>);<span class="comment">//spe_min, spe_max);</span>
<a name="l00248"></a>00248         spefunc-&gt;SetParLimits(SHOTNOISE, CFS.<a class="code" href="classChanFitSettings.html#3c36f9df40b7f856e6813d40944ec8a4">shotnoise_min_bound</a>, CFS.<a class="code" href="classChanFitSettings.html#35b4dd7b88ee079f944bbc4f2cc0ac59">shotnoise_max_bound</a>);<span class="comment">//spe_min, spe_max);         </span>
<a name="l00249"></a>00249         spefunc-&gt;SetParLimits(SIGMA, CFS.<a class="code" href="classChanFitSettings.html#035ca60a8e22586a6a00baea28336965">sigma_min_bound</a>, CFS.<a class="code" href="classChanFitSettings.html#930794952689e7341c907d59114c286f">sigma_max_bound</a>);
<a name="l00250"></a>00250         spefunc-&gt;SetParLimits(P_E, CFS.<a class="code" href="classChanFitSettings.html#8f4a3df7a5dc72eb7961352b50beb5b4">p_E_min_bound</a>, CFS.<a class="code" href="classChanFitSettings.html#54eec7b0f8253fbbf0678d691d8da296">p_E_max_bound</a>);
<a name="l00251"></a>00251         spefunc-&gt;SetParLimits(AMP_E, CFS.<a class="code" href="classChanFitSettings.html#f2fc7a0b0fc1e3504e28e81de243d056">amp_E_min_bound</a>, CFS.<a class="code" href="classChanFitSettings.html#77e4dbfa272af58fa7febbf5abbf63bb">amp_E_max_bound</a>);<span class="comment">//Focus here</span>
<a name="l00252"></a>00252         <span class="keywordflow">if</span>(!allow_bg)
<a name="l00253"></a>00253         {
<a name="l00254"></a>00254             cout&lt;&lt;<span class="stringliteral">"Disallowing exponential background for this fit"</span>&lt;&lt;endl;
<a name="l00255"></a>00255             spefunc-&gt;SetParameter(AMP_E,0);
<a name="l00256"></a>00256             spefunc-&gt;SetParameter(P_E,0);
<a name="l00257"></a>00257             spefunc-&gt;FixParameter(AMP_E,0);
<a name="l00258"></a>00258             spefunc-&gt;FixParameter(P_E,0);
<a name="l00259"></a>00259         }
<a name="l00260"></a>00260                 
<a name="l00261"></a>00261                 
<a name="l00262"></a>00262         spefunc-&gt;SetLineStyle(1);
<a name="l00263"></a>00263         spefunc-&gt;SetLineColor(kBlue);
<a name="l00264"></a>00264     }
<a name="l00265"></a>00265     <span class="keywordflow">else</span>
<a name="l00266"></a>00266     {
<a name="l00267"></a>00267         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;NPAR; i++)
<a name="l00268"></a>00268         {
<a name="l00269"></a>00269             <span class="keywordflow">if</span>(i == CONSTANT || i == LAMBDA)
<a name="l00270"></a>00270                 <span class="keywordflow">continue</span>;
<a name="l00271"></a>00271             <span class="keywordtype">double</span> width=0;
<a name="l00272"></a>00272             spefunc-&gt;SetParLimits(i,
<a name="l00273"></a>00273                                   std::max(0. ,spefunc-&gt;GetParameter(i)-width*spefunc-&gt;GetParError(i)),
<a name="l00274"></a>00274                                   spefunc-&gt;GetParameter(i) + width*spefunc-&gt;GetParError(i));
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277     spefunc-&gt;FixParameter(CONSTANT, nEvtsInRange);
<a name="l00278"></a>00278     spefunc-&gt;FixParameter(PEDMEAN, pedmean);
<a name="l00279"></a>00279         
<a name="l00280"></a>00280     spe-&gt;GetXaxis()-&gt;SetRangeUser(fitmin, fitmax);
<a name="l00281"></a>00281     
<a name="l00282"></a>00282     spe-&gt;Draw();
<a name="l00283"></a>00283     spefunc-&gt;Draw(<span class="stringliteral">"same"</span>);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     <span class="comment">//spe-&gt;Fit(spefunc,"MRES");</span>
<a name="l00286"></a>00286     <span class="comment">//spe-&gt;Fit(spefunc,"MRL");</span>
<a name="l00287"></a>00287     std::cout&lt;&lt;std::endl&lt;&lt;<span class="stringliteral">"Fitting entire spectrum"</span>&lt;&lt;std::endl;
<a name="l00288"></a>00288     TFitResultPtr fitResult = spe-&gt;Fit(spefunc,<span class="stringliteral">"QMRES"</span>);
<a name="l00289"></a>00289     spe-&gt;<a class="code" href="classFitTH1F.html#d67bfb455b1c4686a138fcc46916763e">fitResult</a>= fitResult;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291     <span class="comment">//spefunc-&gt;DrawCopy("same");</span>
<a name="l00292"></a>00292     std::cout&lt;&lt;endl&lt;&lt;<span class="stringliteral">"Fit Results: "</span>&lt;&lt;endl
<a name="l00293"></a>00293              &lt;&lt;<span class="stringliteral">"Fit Status: "</span>&lt;&lt;spe-&gt;<a class="code" href="classFitTH1F.html#d67bfb455b1c4686a138fcc46916763e">fitResult</a>&lt;&lt;endl 
<a name="l00294"></a>00294              &lt;&lt;<span class="stringliteral">"Chi2/NDF = "</span>&lt;&lt;spefunc-&gt;GetChisquare()&lt;&lt;<span class="stringliteral">"/"</span>&lt;&lt;spefunc-&gt;GetNDF()&lt;&lt;endl
<a name="l00295"></a>00295              &lt;&lt;<span class="stringliteral">"Prob = "</span>&lt;&lt;spefunc-&gt;GetProb()&lt;&lt;std::endl&lt;&lt;std::endl;
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;NPAR; i++){  params[i] = spefunc-&gt;GetParameter(i);}
<a name="l00298"></a>00298     TList* funclist = spe-&gt;GetListOfFunctions();
<a name="l00299"></a>00299 
<a name="l00300"></a>00300     <span class="keyword">static</span> TF1* background = <span class="keyword">new</span> TF1(<span class="stringliteral">"background"</span>,<a class="code" href="namespaceFitOverROI.html#a9ef60648d7d520d4dd4a367a37a05f1">background_func</a>,fitmin,fitmax,NPAR);
<a name="l00301"></a>00301     background-&gt;SetRange(fitmin, fitmax);
<a name="l00302"></a>00302     background-&gt;SetLineColor(kRed);
<a name="l00303"></a>00303     background-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00304"></a>00304     funclist-&gt;Add(background-&gt;Clone());
<a name="l00305"></a>00305   
<a name="l00306"></a>00306     <span class="keyword">static</span> TF1* gauss_curve = <span class="keyword">new</span> TF1(<span class="stringliteral">"gause_curve"</span>,<a class="code" href="namespaceFitOverROI.html#cbf4b918771039339f9acb5af44ecbfb">gauss_func</a>,fitmin,fitmax,NPAR);
<a name="l00307"></a>00307     gauss_curve-&gt;SetRange(fitmin, fitmax);
<a name="l00308"></a>00308     gauss_curve-&gt;SetLineColor(kRed);
<a name="l00309"></a>00309     gauss_curve-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00310"></a>00310     funclist-&gt;Add(gauss_curve-&gt;Clone());
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     TF1* response_0_f = (TF1*)gROOT-&gt;GetFunction(<span class="stringliteral">"response_0_f"</span>);       
<a name="l00314"></a>00314     <span class="keywordflow">if</span>(!response_0_f){response_0_f = <span class="keyword">new</span> TF1(<span class="stringliteral">"response_0_f"</span>,<a class="code" href="namespaceFitOverROI.html#782b45be6657463b227de4f1ec72f2f3">response_0</a>,fitmin,fitmax,NPAR);}
<a name="l00315"></a>00315     response_0_f-&gt;SetRange(fitmin, fitmax);
<a name="l00316"></a>00316     response_0_f-&gt;SetLineColor(kGreen); 
<a name="l00317"></a>00317     response_0_f-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00318"></a>00318     response_0_f-&gt;SetRange(fitmin,70);
<a name="l00319"></a>00319     <span class="keywordflow">if</span>(response_0_f){funclist-&gt;Add(response_0_f-&gt;Clone());}
<a name="l00320"></a>00320         
<a name="l00321"></a>00321     TF1* response_1_f = (TF1*)gROOT-&gt;GetFunction(<span class="stringliteral">"response_1_f"</span>);       
<a name="l00322"></a>00322     <span class="keywordflow">if</span>(!response_1_f){response_1_f = <span class="keyword">new</span> TF1(<span class="stringliteral">"response_1_f"</span>,<a class="code" href="namespaceFitOverROI.html#6f7d5a1547b47c190c8ed6f4a759ebd6">response_1</a>,fitmin,fitmax,NPAR);}
<a name="l00323"></a>00323     response_1_f-&gt;SetRange(fitmin, fitmax);
<a name="l00324"></a>00324     response_1_f-&gt;SetLineColor(kMagenta); 
<a name="l00325"></a>00325     response_1_f-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00326"></a>00326     <span class="keywordflow">if</span>(response_1_f){funclist-&gt;Add(response_1_f-&gt;Clone());}
<a name="l00327"></a>00327         
<a name="l00328"></a>00328     TF1* response_2_f = (TF1*)gROOT-&gt;GetFunction(<span class="stringliteral">"response_2_f"</span>);       
<a name="l00329"></a>00329     <span class="keywordflow">if</span>(!response_2_f){response_2_f = <span class="keyword">new</span> TF1(<span class="stringliteral">"response_2_f"</span>,<a class="code" href="namespaceFitOverROI.html#8aa4e710418f691c677a8f843403d2a0">response_2</a>,fitmin,fitmax,NPAR);}
<a name="l00330"></a>00330     response_2_f-&gt;SetRange(fitmin, fitmax);
<a name="l00331"></a>00331     response_2_f-&gt;SetLineColor(kGreen); 
<a name="l00332"></a>00332     response_2_f-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00333"></a>00333     <span class="keywordflow">if</span>(response_2_f){funclist-&gt;Add(response_2_f-&gt;Clone());}
<a name="l00334"></a>00334         
<a name="l00335"></a>00335     TF1* response_multi_f = (TF1*)gROOT-&gt;GetFunction(<span class="stringliteral">"response_multi_f"</span>);       
<a name="l00336"></a>00336     <span class="keywordflow">if</span>(!response_multi_f){response_multi_f = <span class="keyword">new</span> TF1(<span class="stringliteral">"response_multi_f"</span>,<a class="code" href="namespaceFitOverROI.html#7700a1594ba5fda92fcbabed6d06087b">response_multi</a>,fitmin,fitmax,NPAR);}
<a name="l00337"></a>00337     response_multi_f-&gt;SetRange(fitmin, fitmax);
<a name="l00338"></a>00338     response_multi_f-&gt;SetLineColor(kGreen); 
<a name="l00339"></a>00339     response_multi_f-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00340"></a>00340     <span class="keywordflow">if</span>(response_multi_f){funclist-&gt;Add(response_multi_f-&gt;Clone());}
<a name="l00341"></a>00341         
<a name="l00342"></a>00342 
<a name="l00343"></a>00343     <span class="comment">//double thresh = spefunc-&gt;GetParameter(MEAN) - 2.*spefunc-&gt;GetParameter(SIGMA);</span>
<a name="l00344"></a>00344     <span class="comment">//TLine* twosigma = new TLine(thresh, spe-&gt;GetYaxis()-&gt;GetBinLowEdge(1), thresh, 1.1*spe-&gt;GetMaximum());</span>
<a name="l00345"></a>00345     <span class="comment">//twosigma-&gt;SetLineColor(kGreen);</span>
<a name="l00346"></a>00346     <span class="comment">//twosigma-&gt;Draw();</span>
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     cout&lt;&lt;<span class="stringliteral">"Valid Events collected: "</span>&lt;&lt;ntriggers&lt;&lt;std::endl;
<a name="l00349"></a>00349     cout&lt;&lt;<span class="stringliteral">"Events Passing Cuts: "</span> &lt;&lt;spe-&gt;GetEntries()&lt;&lt;std::endl;
<a name="l00350"></a>00350     cout&lt;&lt;<span class="stringliteral">"Noise fraction: "</span>
<a name="l00351"></a>00351         &lt;&lt;spefunc-&gt;GetParameter(AMP_E)/spefunc-&gt;GetParameter(CONSTANT)
<a name="l00352"></a>00352         &lt;&lt;std::endl;
<a name="l00353"></a>00353     cout&lt;&lt;<span class="stringliteral">"Exponential fraction: "</span>&lt;&lt;spefunc-&gt;GetParameter(P_E)&lt;&lt;std::endl;
<a name="l00354"></a>00354     cout&lt;&lt;<span class="stringliteral">"Average photoelectrons per pulse: "</span>&lt;&lt;spefunc-&gt;GetParameter(LAMBDA)
<a name="l00355"></a>00355         &lt;&lt;std::endl;
<a name="l00356"></a>00356     cout&lt;&lt;<span class="stringliteral">"Pedestal Mean: "</span>&lt;&lt;spefunc-&gt;GetParameter(PEDMEAN)&lt;&lt;<span class="stringliteral">" count*samples"</span>&lt;&lt;endl;
<a name="l00357"></a>00357     cout&lt;&lt;<span class="stringliteral">"Pedestal Width: "</span>&lt;&lt;spefunc-&gt;GetParameter(SHOTNOISE)&lt;&lt;<span class="stringliteral">" count*samples"</span>&lt;&lt;endl;
<a name="l00358"></a>00358     <span class="comment">//double mean = spefunc-&gt;GetParameter(MEAN);</span>
<a name="l00359"></a>00359         
<a name="l00360"></a>00360 
<a name="l00361"></a>00361         
<a name="l00362"></a>00362     <span class="keywordtype">double</span> conversion = 0.00049 <span class="comment">/*V/ct*/</span> * 4E-9 <span class="comment">/*ns/samp*/</span> * 1./25. <span class="comment">/*ohm*/</span> *
<a name="l00363"></a>00363         0.1 <span class="comment">/*amplifier*/</span> * 1.E12 <span class="comment">/*pC/C*/</span>;
<a name="l00364"></a>00364         
<a name="l00365"></a>00365     cout&lt;&lt;<span class="stringliteral">"Single photoelectron Peak: "</span>&lt;&lt;<a class="code" href="namespaceFitOverROI.html#cd8556cb95c7193b9f4a2f5dac107c44">m_n</a>(params)&lt;&lt;<span class="stringliteral">" count*samples"</span>&lt;&lt;std::endl
<a name="l00366"></a>00366         &lt;&lt;<span class="stringliteral">"Single photoelectron Width: "</span> &lt;&lt;<a class="code" href="namespaceFitOverROI.html#7146b6447b232829fe65c0c222d1a649">sigma_n</a> (params)&lt;&lt;<span class="stringliteral">" count*samples"</span>&lt;&lt;std::endl
<a name="l00367"></a>00367         &lt;&lt;<span class="stringliteral">"Single photoelectron Charge: "</span>&lt;&lt;<a class="code" href="namespaceFitOverROI.html#cd8556cb95c7193b9f4a2f5dac107c44">m_n</a>(params)*conversion&lt;&lt;<span class="stringliteral">" pC"</span>&lt;&lt;std::endl
<a name="l00368"></a>00368         &lt;&lt;<span class="stringliteral">"Phototube Gain: "</span>&lt;&lt;<a class="code" href="namespaceFitOverROI.html#cd8556cb95c7193b9f4a2f5dac107c44">m_n</a>(params)*conversion / 1.602E-7&lt;&lt;std::endl;
<a name="l00369"></a>00369         
<a name="l00370"></a>00370     <span class="comment">//afan-----------</span>
<a name="l00371"></a>00371     <span class="keywordtype">double</span> pdfmean_approx = mPE*mAMP+(1-mPE)*mMEAN;
<a name="l00372"></a>00372     <span class="comment">//double pdfmean_error_uncorr = sqrt(TMath::Power((mAMP-mMEAN)*spefunc-&gt;GetParError(P_E),2) </span>
<a name="l00373"></a>00373     <span class="comment">//                                     +TMath::Power((1-mPE)*spefunc-&gt;GetParError(MEAN),2)</span>
<a name="l00374"></a>00374     <span class="comment">//                             +TMath::Power(mPE*spefunc-&gt;GetParError(AMP_E),2));</span>
<a name="l00375"></a>00375     <span class="comment">//double pdfmean_error_corr = (pdfmean_error_uncorr </span>
<a name="l00376"></a>00376     <span class="comment">//                       + 2*(mAMP-mMEAN)*(1-mPE)*cov[P_E][MEAN] </span>
<a name="l00377"></a>00377     <span class="comment">//                       + 2*(mAMP-mMEAN)*mPE*cov[P_E][AMP_E] </span>
<a name="l00378"></a>00378     <span class="comment">//                       + 2*(1-mPE)*mPE*cov[MEAN][AMP_E]);</span>
<a name="l00379"></a>00379     cout&lt;&lt;<span class="stringliteral">"Approximated pdfmean (using corr): "</span>&lt;&lt;pdfmean_approx
<a name="l00380"></a>00380         &lt;&lt;<span class="stringliteral">" +- "</span>&lt;&lt;<a class="code" href="namespaceFitOverROI.html#54551afce062ad457573f950974175dc">pdfmean_error_corr</a>(fitResult)&lt;&lt;endl;
<a name="l00381"></a>00381     <span class="keywordflow">return</span> fitResult;
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 
<a name="l00384"></a><a class="code" href="namespaceFitOverROI.html#54551afce062ad457573f950974175dc">00384</a> <span class="keywordtype">double</span> <a class="code" href="namespaceFitOverROI.html#54551afce062ad457573f950974175dc">FitOverROI::pdfmean_error_corr</a>(TFitResultPtr&amp; fitresult)
<a name="l00385"></a>00385 {
<a name="l00386"></a>00386         TMatrixDSym cov = fitresult-&gt;GetCovarianceMatrix();
<a name="l00387"></a>00387   <span class="keyword">const</span> <span class="keywordtype">double</span>* params = fitresult-&gt;GetParams();
<a name="l00388"></a>00388   <span class="keyword">const</span> <span class="keywordtype">double</span>* errors = fitresult-&gt;GetErrors();
<a name="l00389"></a>00389   <span class="comment">//leaving out small correction factor from cut-off gaussian</span>
<a name="l00390"></a>00390     <span class="keywordtype">double</span> pdfmean_error_uncorr_sq = TMath::Power((mAMP-mMEAN)*errors[P_E],2)
<a name="l00391"></a>00391                                        +TMath::Power((1-mPE)*errors[MEAN],2)
<a name="l00392"></a>00392                                        +TMath::Power(mPE*errors[AMP_E],2);
<a name="l00393"></a>00393     <span class="comment">/* cout&lt;&lt;endl&lt;&lt;"mean err: "&lt;&lt;errors[MEAN]&lt;&lt;" amp err: "</span>
<a name="l00394"></a>00394 <span class="comment">               &lt;&lt;errors[AMP_E]&lt;&lt;" p_E err: "</span>
<a name="l00395"></a>00395 <span class="comment">               &lt;&lt;errors[P_E]&lt;&lt;" uncorr error: "</span>
<a name="l00396"></a>00396 <span class="comment">               &lt;&lt;sqrt(pdfmean_error_uncorr_sq)</span>
<a name="l00397"></a>00397 <span class="comment">               &lt;&lt;" cov matrix (mean x p_E): "&lt;&lt;2*(mAMP-mMEAN)*(1-mPE)*cov[P_E][MEAN]</span>
<a name="l00398"></a>00398 <span class="comment">               &lt;&lt;" cov matrix (amp_E x p_E): "&lt;&lt;2*(mAMP-mMEAN)*mPE*cov[P_E][AMP_E] </span>
<a name="l00399"></a>00399 <span class="comment">               &lt;&lt;" cov matrix (mean x amp_E): "&lt;&lt;2*(1-mPE)*mPE*cov[MEAN][AMP_E]</span>
<a name="l00400"></a>00400 <span class="comment">               &lt;&lt;endl;</span>
<a name="l00401"></a>00401 <span class="comment">               cov.Print(); */</span>
<a name="l00402"></a>00402     <span class="keywordflow">return</span> sqrt(pdfmean_error_uncorr_sq + (2*(mAMP-mMEAN)*(1-mPE)*cov[P_E][MEAN] 
<a name="l00403"></a>00403                                    + 2*(mAMP-mMEAN)*mPE*cov[P_E][AMP_E] 
<a name="l00404"></a>00404                                    + 2*(1-mPE)*mPE*cov[MEAN][AMP_E]));
<a name="l00405"></a>00405   
<a name="l00406"></a>00406   
<a name="l00407"></a>00407   
<a name="l00408"></a>00408   
<a name="l00409"></a>00409 }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="comment">/* double FitOverROI::pdfmean_error_corr(TFitResultPtr&amp; fitresult)</span>
<a name="l00412"></a>00412 <span class="comment">{</span>
<a name="l00413"></a>00413 <span class="comment">    TMatrixDSym cov = fitresult-&gt;GetCovarianceMatrix();</span>
<a name="l00414"></a>00414 <span class="comment">    const double* params = fitresult-&gt;GetParams();</span>
<a name="l00415"></a>00415 <span class="comment">    const double* errors = fitresult-&gt;GetErrors();</span>
<a name="l00416"></a>00416 <span class="comment">    double pdfmean_error_uncorr = sqrt(TMath::Power((mAMP-mMEAN)*errors[P_E],2)</span>
<a name="l00417"></a>00417 <span class="comment">                                       +TMath::Power((1-mPE)*errors[MEAN],2)</span>
<a name="l00418"></a>00418 <span class="comment">                                       +TMath::Power(mPE*errors[AMP_E],2));</span>
<a name="l00419"></a>00419 <span class="comment">    cout&lt;&lt;endl&lt;&lt;"pdfmean uncorr:"&lt;&lt;pdfmean_error_uncorr&lt;&lt;endl;</span>
<a name="l00420"></a>00420 <span class="comment">    cout&lt;&lt;"correction: "&lt;&lt;(sqrt(2/TMath::Pi())*mSIG*</span>
<a name="l00421"></a>00421 <span class="comment">         (1/(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG))) + </span>
<a name="l00422"></a>00422 <span class="comment">          mPE/(-2 + TMath::Erfc(mMEAN/(sqrt(2)*mSIG)))))/</span>
<a name="l00423"></a>00423 <span class="comment">        TMath::Power(TMath::E(),TMath::Power(mMEAN,2)/(2.*TMath::Power(mSIG,2)))&lt;&lt;endl;</span>
<a name="l00424"></a>00424 <span class="comment">    cout&lt;&lt;"term 1: "&lt;&lt;2*(mAMP-mMEAN)*(1-mPE)*cov[P_E][MEAN]&lt;&lt;" term 2: "&lt;&lt;2*(mAMP-mMEAN)*mPE*cov[P_E][AMP_E] &lt;&lt;" term 3: "&lt;&lt;2*(1-mPE)*mPE*cov[MEAN][AMP_E]&lt;&lt;endl;</span>
<a name="l00425"></a>00425 <span class="comment">    return pdfmean_error_uncorr + (2*(mAMP-mMEAN)*(1-mPE)*cov[P_E][MEAN] </span>
<a name="l00426"></a>00426 <span class="comment">                + 2*(mAMP-mMEAN)*mPE*cov[P_E][AMP_E] </span>
<a name="l00427"></a>00427 <span class="comment">                + 2*(1-mPE)*mPE*cov[MEAN][AMP_E]);</span>
<a name="l00428"></a>00428 <span class="comment"></span>
<a name="l00429"></a>00429 <span class="comment">} */</span>
<a name="l00430"></a>00430 <span class="comment">/* int ProcessSPEFile(const char* fname, Long_t roi = -1, int channel = -1, </span>
<a name="l00431"></a>00431 <span class="comment">   double emax = -1, bool force_old = false)</span>
<a name="l00432"></a>00432 <span class="comment">   {</span>
<a name="l00433"></a>00433 <span class="comment">   if(!gPad) new TCanvas;</span>
<a name="l00434"></a>00434 <span class="comment">   gPad-&gt;SetLogy();</span>
<a name="l00435"></a>00435 <span class="comment">   gPad-&gt;SetTitle(fname);</span>
<a name="l00436"></a>00436 <span class="comment">   static bool loaded = false;</span>
<a name="l00437"></a>00437 <span class="comment">   if(!loaded){</span>
<a name="l00438"></a>00438 <span class="comment">   gROOT-&gt;ProcessLine(".L lib/libDict.so");</span>
<a name="l00439"></a>00439 <span class="comment">   loaded = true;</span>
<a name="l00440"></a>00440 <span class="comment">   }</span>
<a name="l00441"></a>00441 <span class="comment"></span>
<a name="l00442"></a>00442 <span class="comment">   TFile* fin = new TFile(fname);</span>
<a name="l00443"></a>00443 <span class="comment">   if(!fin-&gt;IsOpen()){</span>
<a name="l00444"></a>00444 <span class="comment">   std::cerr&lt;&lt;"Unable to open file "&lt;&lt;fname&lt;&lt;std::endl;</span>
<a name="l00445"></a>00445 <span class="comment">   return 1;</span>
<a name="l00446"></a>00446 <span class="comment">   }</span>
<a name="l00447"></a>00447 <span class="comment"></span>
<a name="l00448"></a>00448 <span class="comment">   TTree* Events = (TTree*)(fin-&gt;Get("Events"));</span>
<a name="l00449"></a>00449 <span class="comment">   if(!Events){</span>
<a name="l00450"></a>00450 <span class="comment">   std::cerr&lt;&lt;"Unable to load Events tree from file "&lt;&lt;fname&lt;&lt;std::endl;</span>
<a name="l00451"></a>00451 <span class="comment">   return 2;</span>
<a name="l00452"></a>00452 <span class="comment">   }</span>
<a name="l00453"></a>00453 <span class="comment">   TString data_source;</span>
<a name="l00454"></a>00454 <span class="comment">   if(roi == -1) data_source = "channels[].pulses.integral";</span>
<a name="l00455"></a>00455 <span class="comment">   else data_source = TString("-channels[].regions[") + roi</span>
<a name="l00456"></a>00456 <span class="comment">   + TString("].integral");</span>
<a name="l00457"></a>00457 <span class="comment">   if( emax &lt; 0){</span>
<a name="l00458"></a>00458 <span class="comment">   Events-&gt;Draw(data_source+" &gt;&gt; htemp",data_source+" &gt; 0");</span>
<a name="l00459"></a>00459 <span class="comment">   TH1* htemp = (TH1*)(gROOT-&gt;FindObject("htemp"));</span>
<a name="l00460"></a>00460 <span class="comment">   emax = htemp-&gt;GetMean()*HISTOGRAMWIDTH;</span>
<a name="l00461"></a>00461 <span class="comment">   }</span>
<a name="l00462"></a>00462 <span class="comment">        </span>
<a name="l00463"></a>00463 <span class="comment">   TCut min_en = (data_source+" &gt; 0").Data();</span>
<a name="l00464"></a>00464 <span class="comment">   char chstring[100];</span>
<a name="l00465"></a>00465 <span class="comment">   sprintf(chstring,data_source+" &lt; %.0f",emax);</span>
<a name="l00466"></a>00466 <span class="comment">   TCut max_en = chstring;</span>
<a name="l00467"></a>00467 <span class="comment">   sprintf(chstring,"channels[].channel_id == %d",channel);</span>
<a name="l00468"></a>00468 <span class="comment">   TCut chan_cut = (channel == -1 ? "" : chstring);</span>
<a name="l00469"></a>00469 <span class="comment"></span>
<a name="l00470"></a>00470 <span class="comment">   TCut time_cut = (roi == -1 ? get_time_cut(Events, chan_cut) : "" );</span>
<a name="l00471"></a>00471 <span class="comment"></span>
<a name="l00472"></a>00472 <span class="comment">   TCut total_cut = min_en &amp;&amp; max_en &amp;&amp; time_cut &amp;&amp; chan_cut;</span>
<a name="l00473"></a>00473 <span class="comment">        </span>
<a name="l00474"></a>00474 <span class="comment">   Events-&gt;Draw(data_source+" &gt;&gt; hspec",total_cut,"e");</span>
<a name="l00475"></a>00475 <span class="comment">   TH1* hspec = (TH1*)(gROOT-&gt;FindObject("hspec"));</span>
<a name="l00476"></a>00476 <span class="comment"></span>
<a name="l00477"></a>00477 <span class="comment"></span>
<a name="l00478"></a>00478 <span class="comment">   FitSPE(hspec, Events-&gt;GetEntries("channels[].baseline.found_baseline"),</span>
<a name="l00479"></a>00479 <span class="comment">   force_old);</span>
<a name="l00480"></a>00480 <span class="comment"></span>
<a name="l00481"></a>00481 <span class="comment"></span>
<a name="l00482"></a>00482 <span class="comment">   return 0;</span>
<a name="l00483"></a>00483 <span class="comment">   } */</span>
<a name="l00484"></a>00484 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jun 25 13:42:35 2013 for daqman by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
