<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>daqman: analysis/src/FitOverROI.cc Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_09ceee436220c1af2c92d1d2c63c8975.html">analysis</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_319ccb2c1c0085d2ad7e0516ec3ed283.html">src</a>
  </div>
</div>
<div class="contents">
<h1>FitOverROI.cc</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &quot;<a class="code" href="FitOverROI_8hh.html" title="defines FitOverROI namespace and functions for fitting laser data.">FitOverROI.hh</a>&quot;</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include &quot;TMath.h&quot;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;TROOT.h&quot;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &quot;TFitResult.h&quot;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &quot;TSpectrum.h&quot;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &quot;TTree.h&quot;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;TFile.h&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;TF1.h&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;TCanvas.h&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;TPad.h&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;TLine.h&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;TAxis.h&quot;</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;TList.h&quot;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;TCut.h&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;numeric&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;TMatrixDSym.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;TGraph.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="keyword">using namespace </span>std;
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#define HISTOGRAMWIDTH 7</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#define NPEAKS 7</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="preprocessor">#define mCON params[CONSTANT]</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#define mLAM params[LAMBDA]</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define mMEAN params[MEAN]</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#define mSIG params[SIGMA]</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#define mAMP params[AMP_E]</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#define mPE params[P_E]</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#define mSHT params[SHOTNOISE]</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#define mPDM params[PEDMEAN]</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="keyword">const</span> <span class="keywordtype">char</span>* names[] = {<span class="stringliteral">&quot;CONSTANT&quot;</span>,<span class="stringliteral">&quot;LAMBDA&quot;</span>, <span class="stringliteral">&quot;SPE_MEAN&quot;</span>, <span class="stringliteral">&quot;SPE_SIGMA&quot;</span>, <span class="stringliteral">&quot;AMP_E&quot;</span>, <span class="stringliteral">&quot;P_E&quot;</span>, <span class="stringliteral">&quot;SHOTNOISE&quot;</span> ,<span class="stringliteral">&quot;PEDMEAN&quot;</span>,<span class="stringliteral">&quot;NPAR&quot;</span>};
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 Double_t FitOverROI::response_0(Double_t* x, Double_t* params) 
<a name="l00049"></a>00049 {
<a name="l00050"></a>00050     <span class="keywordtype">double</span> y = x[0] - mPDM;
<a name="l00051"></a>00051     <span class="keywordflow">return</span> mCON*TMath::Poisson(0,mLAM)*TMath::Gaus(y, 0, mSHT, <span class="keyword">true</span>);
<a name="l00052"></a>00052 }
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 Double_t FitOverROI::background_func(Double_t* x, Double_t* params)
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056     <span class="keywordtype">double</span> y = x[0] - mPDM;
<a name="l00057"></a>00057 
<a name="l00058"></a>00058     <span class="comment">//mathematica version (my own convolution)</span>
<a name="l00059"></a>00059     <span class="keywordtype">double</span> exp_term=(TMath::Power(TMath::E(),(-2*mAMP*y + mSHT*mSHT)/
<a name="l00060"></a>00060                                   (2.*mAMP*mAMP))*mPE*
<a name="l00061"></a>00061                      (1 + TMath::Erf(((mAMP*y)/mSHT - mSHT)/(sqrt(2)*mAMP))))/
<a name="l00062"></a>00062         (2.*mAMP);
<a name="l00063"></a>00063     <span class="keywordflow">return</span> mCON*TMath::Poisson(1,mLAM)*exp_term;
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 Double_t FitOverROI::gauss_func(Double_t* x, Double_t* params)
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068     <span class="keywordtype">double</span> y = x[0] - mPDM;
<a name="l00069"></a>00069     <span class="keywordtype">double</span> sigma_1=sqrt(mSHT*mSHT + mSIG*mSIG); 
<a name="l00070"></a>00070         
<a name="l00071"></a>00071     <span class="keywordtype">double</span> gauss_term= (1-mPE)*(TMath::Power(TMath::E(), - (mMEAN-y)*(mMEAN-y)/(2*sigma_1*sigma_1)) *
<a name="l00072"></a>00072                                 (1 + TMath::Erf((mMEAN*mSHT*mSHT + mSIG*mSIG*y)/(sqrt(2) * mSIG*mSHT *sigma_1))) /
<a name="l00073"></a>00073                                 (sqrt(2*TMath::Pi())*sigma_1 * (1+ TMath::Erf(mMEAN/(sqrt(2)*mSIG)))));
<a name="l00074"></a>00074         
<a name="l00075"></a>00075         
<a name="l00076"></a>00076     <span class="keywordtype">double</span> response=mCON*TMath::Poisson(1,mLAM)*gauss_term;
<a name="l00077"></a>00077     <span class="keywordflow">return</span> response;
<a name="l00078"></a>00078 }  
<a name="l00079"></a>00079   
<a name="l00080"></a>00080 Double_t FitOverROI::response_1(Double_t* x, Double_t* params)
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082     <span class="keywordtype">double</span> exp_term= background_func(x, params);
<a name="l00083"></a>00083         
<a name="l00084"></a>00084     <span class="keywordtype">double</span> gauss_term= gauss_func(x, params);
<a name="l00085"></a>00085         
<a name="l00086"></a>00086         
<a name="l00087"></a>00087     <span class="keywordtype">double</span> response=gauss_term+exp_term;
<a name="l00088"></a>00088     <span class="keywordflow">return</span> response;
<a name="l00089"></a>00089 }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 Double_t FitOverROI::response_2(Double_t* x, Double_t* params)
<a name="l00093"></a>00093 {
<a name="l00094"></a>00094     <span class="keywordtype">double</span> y = x[0] - mPDM;
<a name="l00095"></a>00095     <span class="keywordtype">double</span> response=((TMath::Power(TMath::E(),(-2*mAMP*y + TMath::Power(mSHT,2))/
<a name="l00096"></a>00096                                    (2.*TMath::Power(mAMP,2)))*mPE*mPE*
<a name="l00097"></a>00097                       (mAMP*y - TMath::Power(mSHT,2)))/TMath::Power(mAMP,3) + 
<a name="l00098"></a>00098                      (2*TMath::Power(-1 + mPE,2)*sqrt(2/TMath::Pi()))/
<a name="l00099"></a>00099                      (TMath::Power(TMath::E(),TMath::Power(-2*mMEAN + y,2)/
<a name="l00100"></a>00100                                    (2.*(TMath::Power(mSHT,2) + 
<a name="l00101"></a>00101                                         2*TMath::Power(mSIG,2))))*mSHT*
<a name="l00102"></a>00102                       sqrt(2/TMath::Power(mSHT,2) + TMath::Power(mSIG,-2))*
<a name="l00103"></a>00103                       mSIG*TMath::Power(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG)),2)) 
<a name="l00104"></a>00104                      + (2*TMath::Power(TMath::E(),
<a name="l00105"></a>00105                                        (2*mAMP*mMEAN - 2*mAMP*y + TMath::Power(mSHT,2) + 
<a name="l00106"></a>00106                                         TMath::Power(mSIG,2))/(2.*TMath::Power(mAMP,2)))*
<a name="l00107"></a>00107                         (-1 + mPE)*mPE*
<a name="l00108"></a>00108                         (-1 + TMath::Erf((mAMP*(mMEAN - y) + 
<a name="l00109"></a>00109                                           TMath::Power(mSHT,2) + TMath::Power(mSIG,2))/
<a name="l00110"></a>00110                                          (mAMP*sqrt(2*TMath::Power(mSHT,2) + 
<a name="l00111"></a>00111                                                     2*TMath::Power(mSIG,2))))))
<a name="l00112"></a>00112                      /(mAMP*(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG)))));
<a name="l00113"></a>00113     
<a name="l00114"></a>00114     <span class="keywordflow">return</span> TMath::Poisson(2,mLAM)*mCON*response;
<a name="l00115"></a>00115     
<a name="l00116"></a>00116       <span class="comment">/*double sigma_1=sqrt(mSHT*mSHT + mSIG*mSIG);     </span>
<a name="l00117"></a>00117 <span class="comment">      </span>
<a name="l00118"></a>00118 <span class="comment">      double response= TMath::Poisson(2,mLAM)*(mPE*mPE*y/(mAMP*mAMP) * TMath::Power(TMath::E(), -y/mAMP)+ </span>
<a name="l00119"></a>00119 <span class="comment">      2 * (1-mPE)*mPE/(sqrt(2*TMath::Pi())*sigma_1) * TMath::Power(TMath::E(), -0.5*(y-mMEAN-mAMP)*(y-mMEAN-mAMP)/(sigma_1*sigma_1)) + </span>
<a name="l00120"></a>00120 <span class="comment">      (1-mPE)*(1-mPE)/(2 *sqrt(TMath::Pi())*sigma_1) *TMath::Power(TMath::E(),-0.5 *(y- 2*mMEAN)*(y- 2*mMEAN)/(sigma_1 * sigma_1 *2)));</span>
<a name="l00121"></a>00121 <span class="comment">      return mCON*response;*/</span>
<a name="l00122"></a>00122 }
<a name="l00123"></a>00123         
<a name="l00124"></a>00124 Double_t FitOverROI::m_n(<span class="keyword">const</span> Double_t* params)
<a name="l00125"></a>00125 {
<a name="l00126"></a>00126     <span class="keywordflow">return</span> mMEAN + mAMP*mPE - mMEAN*mPE + 
<a name="l00127"></a>00127         (sqrt(2/TMath::Pi())*mSIG*
<a name="l00128"></a>00128          (1/(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG))) + 
<a name="l00129"></a>00129           mPE/(-2 + TMath::Erfc(mMEAN/(sqrt(2)*mSIG)))))/
<a name="l00130"></a>00130         TMath::Power(TMath::E(),TMath::Power(mMEAN,2)/(2.*TMath::Power(mSIG,2)));
<a name="l00131"></a>00131 }
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 Double_t FitOverROI::sigma_n(<span class="keyword">const</span>  Double_t* params)
<a name="l00134"></a>00134 {
<a name="l00135"></a>00135     <span class="keywordflow">return</span> sqrt(-(TMath::Power(mMEAN,2)*(-1 + mPE)) + 
<a name="l00136"></a>00136                 2*TMath::Power(mAMP,2)*mPE  - 
<a name="l00137"></a>00137                 (-1 + mPE)*TMath::Power(mSIG,2) - 
<a name="l00138"></a>00138                 TMath::Power(mMEAN + mAMP*mPE - mMEAN*mPE + 
<a name="l00139"></a>00139                              (sqrt(2/TMath::Pi())*mSIG*
<a name="l00140"></a>00140                               (1/(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG))) + 
<a name="l00141"></a>00141                                mPE/(-2 + TMath::Erfc(mMEAN/(sqrt(2)*mSIG)))
<a name="l00142"></a>00142                                   ))/
<a name="l00143"></a>00143                              TMath::Power(TMath::E(),TMath::Power(mMEAN,2)/
<a name="l00144"></a>00144                                           (2.*TMath::Power(mSIG,2))),2) + 
<a name="l00145"></a>00145                 (mMEAN*sqrt(2/TMath::Pi())*mSIG*
<a name="l00146"></a>00146                  (1/(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG))) + 
<a name="l00147"></a>00147                   mPE/(-2 + TMath::Erfc(mMEAN/(sqrt(2)*mSIG)))))
<a name="l00148"></a>00148                 /TMath::Power(TMath::E(),TMath::Power(mMEAN,2)/
<a name="l00149"></a>00149                               (2.*TMath::Power(mSIG,2))));
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151            
<a name="l00152"></a>00152 Double_t FitOverROI::response_multi(Double_t* x, Double_t* params)
<a name="l00153"></a>00153 {       
<a name="l00154"></a>00154     <span class="keywordtype">double</span> y = x[0] - mPDM;
<a name="l00155"></a>00155         
<a name="l00156"></a>00156                 
<a name="l00157"></a>00157     <span class="keywordtype">double</span> response=0;
<a name="l00158"></a>00158         
<a name="l00159"></a>00159     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=3; i&lt;=NPEAKS; i++)
<a name="l00160"></a>00160     {
<a name="l00161"></a>00161         response += TMath::Poisson(i,mLAM) *TMath::Gaus(y,m_n(params)*i,sqrt(i*sigma_n(params)*sigma_n(params)+TMath::Power(mSHT,2)),<span class="keyword">true</span>);
<a name="l00162"></a>00162     }
<a name="l00163"></a>00163     <span class="keywordflow">return</span> mCON*response;
<a name="l00164"></a>00164 }       
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 Double_t FitOverROI::SPEFunc(Double_t* x, Double_t* params)
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168     <span class="keywordtype">double</span> sig = (response_0(x, params)+response_1(x,params)+response_2(x,params)+response_multi(x,params));    
<a name="l00169"></a>00169     <span class="comment">/*double fixerparams[] = {mCON, 0.00143997, 83.9085, 29.0772, 149.998, 0.704112 , mSHT };</span>
<a name="l00170"></a>00170 <span class="comment">      double base= (response_1(x,fixerparams)+response_2(x,fixerparams)+response_multi(x,fixerparams));</span>
<a name="l00171"></a>00171 <span class="comment">      return sig*(TMath::Poisson(0,0.00143997))+base;*/</span>
<a name="l00172"></a>00172     <span class="keywordflow">return</span> sig;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 TFitResultPtr FitOverROI::FitSPE(<a class="code" href="classFitTH1F.html" title="A small extensin of TH1F to store a FitResults.">FitTH1F</a>* spe, <a class="code" href="classChanFitSettings.html" title="Base class representing a cut to check whether a module should run.">ChanFitSettings</a>&amp; CFS, <span class="keywordtype">int</span> ntriggers,
<a name="l00177"></a>00177                                  <span class="keywordtype">bool</span> allow_bg,
<a name="l00178"></a>00178                                  <span class="keywordtype">bool</span> force_old)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180     
<a name="l00181"></a>00181     TF1* spefunc = (TF1*)gROOT-&gt;GetFunction(<span class="stringliteral">&quot;spefunc&quot;</span>);
<a name="l00182"></a>00182     <span class="keywordtype">int</span> nEvtsInRange = (int)spe-&gt;Integral(0,spe-&gt;GetNbinsX()+1,<span class="stringliteral">&quot;width&quot;</span>);
<a name="l00183"></a>00183         
<a name="l00184"></a>00184     spe-&gt;GetXaxis()-&gt;SetRangeUser(CFS.range_min, CFS.range_max);
<a name="l00185"></a>00185         
<a name="l00186"></a>00186     <span class="keywordtype">double</span> fitmin, fitmax;
<a name="l00187"></a>00187     fitmin = spe-&gt;GetBinLowEdge(spe-&gt;GetXaxis()-&gt;GetFirst());
<a name="l00188"></a>00188     fitmax = 0;
<a name="l00189"></a>00189     <span class="comment">//find the last non-zero bin</span>
<a name="l00190"></a>00190     <span class="keywordtype">int</span> bin = spe-&gt;GetXaxis()-&gt;GetLast();
<a name="l00191"></a>00191     <span class="comment">//bin = spe-&gt;GetNbinsX()+1;</span>
<a name="l00192"></a>00192                 
<a name="l00193"></a>00193     <span class="keywordflow">while</span>(spe-&gt;GetBinContent(bin) == 0) {bin--;}
<a name="l00194"></a>00194     fitmax = spe-&gt;GetBinLowEdge(bin);
<a name="l00195"></a>00195     fitmax = fitmax*1; 
<a name="l00196"></a>00196 
<a name="l00197"></a>00197     <span class="comment">//Pedestal centering</span>
<a name="l00198"></a>00198         
<a name="l00199"></a>00199     Double_t pedmean = CFS.pedmean_min_bound;
<a name="l00200"></a>00200     <span class="keywordflow">if</span>(fitmin&lt;0 &amp;&amp; !force_old &amp;&amp; (max(fitmin,CFS.pedrange_min)&lt; min(CFS.pedrange_max,fitmax)))
<a name="l00201"></a>00201     {
<a name="l00202"></a>00202         spe-&gt;GetXaxis()-&gt;SetRangeUser(max(fitmin,CFS.pedrange_min), min(CFS.pedrange_max,fitmax));
<a name="l00203"></a>00203         std::cout&lt;&lt;<span class="stringliteral">&quot;Fitting pedestal in range [&quot;</span>&lt;&lt;max(fitmin,CFS.pedrange_min)&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;min(fitmax,CFS.pedrange_max)&lt;&lt;<span class="stringliteral">&quot;]&quot;</span>&lt;&lt;std::endl;
<a name="l00204"></a>00204         TFitResultPtr pedfit = spe-&gt;Fit(<span class="stringliteral">&quot;gaus&quot;</span>,<span class="stringliteral">&quot;QMIS&quot;</span>);
<a name="l00205"></a>00205         <span class="keywordflow">if</span>(pedfit.Get())
<a name="l00206"></a>00206         {
<a name="l00207"></a>00207             pedmean = pedfit-&gt;Value(1);
<a name="l00208"></a>00208         }
<a name="l00209"></a>00209         <span class="keywordflow">else</span>{pedmean=0;}
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211     <span class="keywordflow">if</span>(force_old)
<a name="l00212"></a>00212     {
<a name="l00213"></a>00213         pedmean=spefunc-&gt;GetParameter(PEDMEAN);
<a name="l00214"></a>00214     }
<a name="l00215"></a>00215         
<a name="l00216"></a>00216     <span class="keywordtype">double</span> params[NPAR];
<a name="l00217"></a>00217     <span class="comment">//find the likely place for the single p.e. peak</span>
<a name="l00218"></a>00218     bin = spe-&gt;FindBin(0);
<a name="l00219"></a>00219     <span class="comment">//params[SHOTNOISE] = FindExtremum(bin, spe, FORWARD, MINIMUM)/3.;</span>
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 
<a name="l00222"></a>00222     <span class="keywordflow">if</span>(!force_old || !spefunc)
<a name="l00223"></a>00223     {
<a name="l00224"></a>00224         params[SHOTNOISE] = CFS.shotnoise_start_value;
<a name="l00225"></a>00225         params[MEAN] = CFS.mean_start_value;
<a name="l00226"></a>00226         params[SIGMA] = CFS.sigma_start_value;
<a name="l00227"></a>00227         params[LAMBDA] = CFS.lambda_start_value;
<a name="l00228"></a>00228         <span class="keywordflow">if</span>(CFS.constant_start_value)
<a name="l00229"></a>00229         { 
<a name="l00230"></a>00230             params[CONSTANT] = nEvtsInRange;
<a name="l00231"></a>00231         } 
<a name="l00232"></a>00232         <span class="keywordflow">else</span>
<a name="l00233"></a>00233         {  
<a name="l00234"></a>00234             params[CONSTANT] = CFS.constant_start_value;
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236         params[AMP_E] = CFS.amp_E_start_value;
<a name="l00237"></a>00237         params[P_E] = CFS.p_E_start_value;  
<a name="l00238"></a>00238                 
<a name="l00239"></a>00239         spefunc = <span class="keyword">new</span> TF1(<span class="stringliteral">&quot;spefunc&quot;</span>, SPEFunc, fitmin, fitmax, NPAR);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241         spefunc-&gt;SetParameters(params);
<a name="l00242"></a>00242         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;NPAR; i++)
<a name="l00243"></a>00243             spefunc-&gt;SetParName(i, names[i]);
<a name="l00244"></a>00244         <span class="comment">//spefunc-&gt;SetParLimits(CONSTANT, 0 , params[CONSTANT]);</span>
<a name="l00245"></a>00245         <span class="comment">//DIVOT</span>
<a name="l00246"></a>00246         spefunc-&gt;SetParLimits(LAMBDA, CFS.lambda_min_bound, CFS.lambda_max_bound);
<a name="l00247"></a>00247         spefunc-&gt;SetParLimits(MEAN, CFS.mean_min_bound, CFS.mean_max_bound);<span class="comment">//spe_min, spe_max);</span>
<a name="l00248"></a>00248         spefunc-&gt;SetParLimits(SHOTNOISE, CFS.shotnoise_min_bound, CFS.shotnoise_max_bound);<span class="comment">//spe_min, spe_max);         </span>
<a name="l00249"></a>00249         spefunc-&gt;SetParLimits(SIGMA, CFS.sigma_min_bound, CFS.sigma_max_bound);
<a name="l00250"></a>00250         spefunc-&gt;SetParLimits(P_E, CFS.p_E_min_bound, CFS.p_E_max_bound);
<a name="l00251"></a>00251         spefunc-&gt;SetParLimits(AMP_E, CFS.amp_E_min_bound, CFS.amp_E_max_bound);<span class="comment">//Focus here</span>
<a name="l00252"></a>00252         <span class="keywordflow">if</span>(!allow_bg)
<a name="l00253"></a>00253         {
<a name="l00254"></a>00254             cout&lt;&lt;<span class="stringliteral">&quot;Disallowing exponential background for this fit&quot;</span>&lt;&lt;endl;
<a name="l00255"></a>00255             spefunc-&gt;SetParameter(AMP_E,0);
<a name="l00256"></a>00256             spefunc-&gt;SetParameter(P_E,0);
<a name="l00257"></a>00257             spefunc-&gt;FixParameter(AMP_E,0);
<a name="l00258"></a>00258             spefunc-&gt;FixParameter(P_E,0);
<a name="l00259"></a>00259         }
<a name="l00260"></a>00260                 
<a name="l00261"></a>00261                 
<a name="l00262"></a>00262         spefunc-&gt;SetLineStyle(1);
<a name="l00263"></a>00263         spefunc-&gt;SetLineColor(kBlue);
<a name="l00264"></a>00264     }
<a name="l00265"></a>00265     <span class="keywordflow">else</span>
<a name="l00266"></a>00266     {
<a name="l00267"></a>00267         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;NPAR; i++)
<a name="l00268"></a>00268         {
<a name="l00269"></a>00269             <span class="keywordflow">if</span>(i == CONSTANT || i == LAMBDA)
<a name="l00270"></a>00270                 <span class="keywordflow">continue</span>;
<a name="l00271"></a>00271             <span class="keywordtype">double</span> width=0;
<a name="l00272"></a>00272             spefunc-&gt;SetParLimits(i,
<a name="l00273"></a>00273                                   std::max(0. ,spefunc-&gt;GetParameter(i)-width*spefunc-&gt;GetParError(i)),
<a name="l00274"></a>00274                                   spefunc-&gt;GetParameter(i) + width*spefunc-&gt;GetParError(i));
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277     spefunc-&gt;FixParameter(CONSTANT, nEvtsInRange);
<a name="l00278"></a>00278     spefunc-&gt;FixParameter(PEDMEAN, pedmean);
<a name="l00279"></a>00279         
<a name="l00280"></a>00280     spe-&gt;GetXaxis()-&gt;SetRangeUser(fitmin, fitmax);
<a name="l00281"></a>00281     
<a name="l00282"></a>00282     spe-&gt;Draw();
<a name="l00283"></a>00283     spefunc-&gt;Draw(<span class="stringliteral">&quot;same&quot;</span>);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     <span class="comment">//spe-&gt;Fit(spefunc,&quot;MRES&quot;);</span>
<a name="l00286"></a>00286     <span class="comment">//spe-&gt;Fit(spefunc,&quot;MRL&quot;);</span>
<a name="l00287"></a>00287     std::cout&lt;&lt;std::endl&lt;&lt;<span class="stringliteral">&quot;Fitting entire spectrum&quot;</span>&lt;&lt;std::endl;
<a name="l00288"></a>00288     TFitResultPtr fitResult = spe-&gt;Fit(spefunc,<span class="stringliteral">&quot;QMRES&quot;</span>);
<a name="l00289"></a>00289     spe-&gt;fitResult= fitResult;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291     <span class="comment">//spefunc-&gt;DrawCopy(&quot;same&quot;);</span>
<a name="l00292"></a>00292     std::cout&lt;&lt;endl&lt;&lt;<span class="stringliteral">&quot;Fit Results: &quot;</span>&lt;&lt;endl
<a name="l00293"></a>00293              &lt;&lt;<span class="stringliteral">&quot;Fit Status: &quot;</span>&lt;&lt;spe-&gt;fitResult&lt;&lt;endl 
<a name="l00294"></a>00294              &lt;&lt;<span class="stringliteral">&quot;Chi2/NDF = &quot;</span>&lt;&lt;spefunc-&gt;GetChisquare()&lt;&lt;<span class="stringliteral">&quot;/&quot;</span>&lt;&lt;spefunc-&gt;GetNDF()&lt;&lt;endl
<a name="l00295"></a>00295              &lt;&lt;<span class="stringliteral">&quot;Prob = &quot;</span>&lt;&lt;spefunc-&gt;GetProb()&lt;&lt;std::endl&lt;&lt;std::endl;
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;NPAR; i++){  params[i] = spefunc-&gt;GetParameter(i);}
<a name="l00298"></a>00298     TList* funclist = spe-&gt;GetListOfFunctions();
<a name="l00299"></a>00299 
<a name="l00300"></a>00300     <span class="keyword">static</span> TF1* background = <span class="keyword">new</span> TF1(<span class="stringliteral">&quot;background&quot;</span>,background_func,fitmin,fitmax,NPAR);
<a name="l00301"></a>00301     background-&gt;SetRange(fitmin, fitmax);
<a name="l00302"></a>00302     background-&gt;SetLineColor(kRed);
<a name="l00303"></a>00303     background-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00304"></a>00304     funclist-&gt;Add(background-&gt;Clone());
<a name="l00305"></a>00305   
<a name="l00306"></a>00306     <span class="keyword">static</span> TF1* gauss_curve = <span class="keyword">new</span> TF1(<span class="stringliteral">&quot;gause_curve&quot;</span>,gauss_func,fitmin,fitmax,NPAR);
<a name="l00307"></a>00307     gauss_curve-&gt;SetRange(fitmin, fitmax);
<a name="l00308"></a>00308     gauss_curve-&gt;SetLineColor(kRed);
<a name="l00309"></a>00309     gauss_curve-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00310"></a>00310     funclist-&gt;Add(gauss_curve-&gt;Clone());
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     TF1* response_0_f = (TF1*)gROOT-&gt;GetFunction(<span class="stringliteral">&quot;response_0_f&quot;</span>);       
<a name="l00314"></a>00314     <span class="keywordflow">if</span>(!response_0_f){response_0_f = <span class="keyword">new</span> TF1(<span class="stringliteral">&quot;response_0_f&quot;</span>,response_0,fitmin,fitmax,NPAR);}
<a name="l00315"></a>00315     response_0_f-&gt;SetRange(fitmin, fitmax);
<a name="l00316"></a>00316     response_0_f-&gt;SetLineColor(kGreen); 
<a name="l00317"></a>00317     response_0_f-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00318"></a>00318     response_0_f-&gt;SetRange(fitmin,70);
<a name="l00319"></a>00319     <span class="keywordflow">if</span>(response_0_f){funclist-&gt;Add(response_0_f-&gt;Clone());}
<a name="l00320"></a>00320         
<a name="l00321"></a>00321     TF1* response_1_f = (TF1*)gROOT-&gt;GetFunction(<span class="stringliteral">&quot;response_1_f&quot;</span>);       
<a name="l00322"></a>00322     <span class="keywordflow">if</span>(!response_1_f){response_1_f = <span class="keyword">new</span> TF1(<span class="stringliteral">&quot;response_1_f&quot;</span>,response_1,fitmin,fitmax,NPAR);}
<a name="l00323"></a>00323     response_1_f-&gt;SetRange(fitmin, fitmax);
<a name="l00324"></a>00324     response_1_f-&gt;SetLineColor(kMagenta); 
<a name="l00325"></a>00325     response_1_f-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00326"></a>00326     <span class="keywordflow">if</span>(response_1_f){funclist-&gt;Add(response_1_f-&gt;Clone());}
<a name="l00327"></a>00327         
<a name="l00328"></a>00328     TF1* response_2_f = (TF1*)gROOT-&gt;GetFunction(<span class="stringliteral">&quot;response_2_f&quot;</span>);       
<a name="l00329"></a>00329     <span class="keywordflow">if</span>(!response_2_f){response_2_f = <span class="keyword">new</span> TF1(<span class="stringliteral">&quot;response_2_f&quot;</span>,response_2,fitmin,fitmax,NPAR);}
<a name="l00330"></a>00330     response_2_f-&gt;SetRange(fitmin, fitmax);
<a name="l00331"></a>00331     response_2_f-&gt;SetLineColor(kGreen); 
<a name="l00332"></a>00332     response_2_f-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00333"></a>00333     <span class="keywordflow">if</span>(response_2_f){funclist-&gt;Add(response_2_f-&gt;Clone());}
<a name="l00334"></a>00334         
<a name="l00335"></a>00335     TF1* response_multi_f = (TF1*)gROOT-&gt;GetFunction(<span class="stringliteral">&quot;response_multi_f&quot;</span>);       
<a name="l00336"></a>00336     <span class="keywordflow">if</span>(!response_multi_f){response_multi_f = <span class="keyword">new</span> TF1(<span class="stringliteral">&quot;response_multi_f&quot;</span>,response_multi,fitmin,fitmax,NPAR);}
<a name="l00337"></a>00337     response_multi_f-&gt;SetRange(fitmin, fitmax);
<a name="l00338"></a>00338     response_multi_f-&gt;SetLineColor(kGreen); 
<a name="l00339"></a>00339     response_multi_f-&gt;SetParameters(spefunc-&gt;GetParameters());
<a name="l00340"></a>00340     <span class="keywordflow">if</span>(response_multi_f){funclist-&gt;Add(response_multi_f-&gt;Clone());}
<a name="l00341"></a>00341         
<a name="l00342"></a>00342 
<a name="l00343"></a>00343     <span class="comment">//double thresh = spefunc-&gt;GetParameter(MEAN) - 2.*spefunc-&gt;GetParameter(SIGMA);</span>
<a name="l00344"></a>00344     <span class="comment">//TLine* twosigma = new TLine(thresh, spe-&gt;GetYaxis()-&gt;GetBinLowEdge(1), thresh, 1.1*spe-&gt;GetMaximum());</span>
<a name="l00345"></a>00345     <span class="comment">//twosigma-&gt;SetLineColor(kGreen);</span>
<a name="l00346"></a>00346     <span class="comment">//twosigma-&gt;Draw();</span>
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     cout&lt;&lt;<span class="stringliteral">&quot;Valid Events collected: &quot;</span>&lt;&lt;ntriggers&lt;&lt;std::endl;
<a name="l00349"></a>00349     cout&lt;&lt;<span class="stringliteral">&quot;Events Passing Cuts: &quot;</span> &lt;&lt;spe-&gt;GetEntries()&lt;&lt;std::endl;
<a name="l00350"></a>00350     cout&lt;&lt;<span class="stringliteral">&quot;Noise fraction: &quot;</span>
<a name="l00351"></a>00351         &lt;&lt;spefunc-&gt;GetParameter(AMP_E)/spefunc-&gt;GetParameter(CONSTANT)
<a name="l00352"></a>00352         &lt;&lt;std::endl;
<a name="l00353"></a>00353     cout&lt;&lt;<span class="stringliteral">&quot;Exponential fraction: &quot;</span>&lt;&lt;spefunc-&gt;GetParameter(P_E)&lt;&lt;std::endl;
<a name="l00354"></a>00354     cout&lt;&lt;<span class="stringliteral">&quot;Average photoelectrons per pulse: &quot;</span>&lt;&lt;spefunc-&gt;GetParameter(LAMBDA)
<a name="l00355"></a>00355         &lt;&lt;std::endl;
<a name="l00356"></a>00356     cout&lt;&lt;<span class="stringliteral">&quot;Pedestal Mean: &quot;</span>&lt;&lt;spefunc-&gt;GetParameter(PEDMEAN)&lt;&lt;<span class="stringliteral">&quot; count*samples&quot;</span>&lt;&lt;endl;
<a name="l00357"></a>00357     cout&lt;&lt;<span class="stringliteral">&quot;Pedestal Width: &quot;</span>&lt;&lt;spefunc-&gt;GetParameter(SHOTNOISE)&lt;&lt;<span class="stringliteral">&quot; count*samples&quot;</span>&lt;&lt;endl;
<a name="l00358"></a>00358     <span class="comment">//double mean = spefunc-&gt;GetParameter(MEAN);</span>
<a name="l00359"></a>00359         
<a name="l00360"></a>00360 
<a name="l00361"></a>00361         
<a name="l00362"></a>00362     <span class="keywordtype">double</span> conversion = 0.00049 <span class="comment">/*V/ct*/</span> * 4E-9 <span class="comment">/*ns/samp*/</span> * 1./25. <span class="comment">/*ohm*/</span> *
<a name="l00363"></a>00363         0.1 <span class="comment">/*amplifier*/</span> * 1.E12 <span class="comment">/*pC/C*/</span>;
<a name="l00364"></a>00364         
<a name="l00365"></a>00365     cout&lt;&lt;<span class="stringliteral">&quot;Single photoelectron Peak: &quot;</span>&lt;&lt;m_n(params)&lt;&lt;<span class="stringliteral">&quot; count*samples&quot;</span>&lt;&lt;std::endl
<a name="l00366"></a>00366         &lt;&lt;<span class="stringliteral">&quot;Single photoelectron Width: &quot;</span> &lt;&lt;sigma_n (params)&lt;&lt;<span class="stringliteral">&quot; count*samples&quot;</span>&lt;&lt;std::endl
<a name="l00367"></a>00367         &lt;&lt;<span class="stringliteral">&quot;Single photoelectron Charge: &quot;</span>&lt;&lt;m_n(params)*conversion&lt;&lt;<span class="stringliteral">&quot; pC&quot;</span>&lt;&lt;std::endl
<a name="l00368"></a>00368         &lt;&lt;<span class="stringliteral">&quot;Phototube Gain: &quot;</span>&lt;&lt;m_n(params)*conversion / 1.602E-7&lt;&lt;std::endl;
<a name="l00369"></a>00369         
<a name="l00370"></a>00370     <span class="comment">//afan-----------</span>
<a name="l00371"></a>00371     <span class="keywordtype">double</span> pdfmean_approx = mPE*mAMP+(1-mPE)*mMEAN;
<a name="l00372"></a>00372     <span class="comment">//double pdfmean_error_uncorr = sqrt(TMath::Power((mAMP-mMEAN)*spefunc-&gt;GetParError(P_E),2) </span>
<a name="l00373"></a>00373     <span class="comment">//                                     +TMath::Power((1-mPE)*spefunc-&gt;GetParError(MEAN),2)</span>
<a name="l00374"></a>00374     <span class="comment">//                             +TMath::Power(mPE*spefunc-&gt;GetParError(AMP_E),2));</span>
<a name="l00375"></a>00375     <span class="comment">//double pdfmean_error_corr = (pdfmean_error_uncorr </span>
<a name="l00376"></a>00376     <span class="comment">//                       + 2*(mAMP-mMEAN)*(1-mPE)*cov[P_E][MEAN] </span>
<a name="l00377"></a>00377     <span class="comment">//                       + 2*(mAMP-mMEAN)*mPE*cov[P_E][AMP_E] </span>
<a name="l00378"></a>00378     <span class="comment">//                       + 2*(1-mPE)*mPE*cov[MEAN][AMP_E]);</span>
<a name="l00379"></a>00379     cout&lt;&lt;<span class="stringliteral">&quot;Approximated pdfmean (using corr): &quot;</span>&lt;&lt;pdfmean_approx
<a name="l00380"></a>00380         &lt;&lt;<span class="stringliteral">&quot; +- &quot;</span>&lt;&lt;pdfmean_error_corr(fitResult)&lt;&lt;endl;
<a name="l00381"></a>00381     <span class="keywordflow">return</span> fitResult;
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 <span class="keywordtype">double</span> FitOverROI::pdfmean_error_corr(TFitResultPtr&amp; fitresult)
<a name="l00385"></a>00385 {
<a name="l00386"></a>00386         TMatrixDSym cov = fitresult-&gt;GetCovarianceMatrix();
<a name="l00387"></a>00387   <span class="keyword">const</span> <span class="keywordtype">double</span>* params = fitresult-&gt;GetParams();
<a name="l00388"></a>00388   <span class="keyword">const</span> <span class="keywordtype">double</span>* errors = fitresult-&gt;GetErrors();
<a name="l00389"></a>00389   <span class="comment">//leaving out small correction factor from cut-off gaussian</span>
<a name="l00390"></a>00390     <span class="keywordtype">double</span> pdfmean_error_uncorr_sq = TMath::Power((mAMP-mMEAN)*errors[P_E],2)
<a name="l00391"></a>00391                                        +TMath::Power((1-mPE)*errors[MEAN],2)
<a name="l00392"></a>00392                                        +TMath::Power(mPE*errors[AMP_E],2);
<a name="l00393"></a>00393     <span class="comment">/* cout&lt;&lt;endl&lt;&lt;&quot;mean err: &quot;&lt;&lt;errors[MEAN]&lt;&lt;&quot; amp err: &quot;</span>
<a name="l00394"></a>00394 <span class="comment">               &lt;&lt;errors[AMP_E]&lt;&lt;&quot; p_E err: &quot;</span>
<a name="l00395"></a>00395 <span class="comment">               &lt;&lt;errors[P_E]&lt;&lt;&quot; uncorr error: &quot;</span>
<a name="l00396"></a>00396 <span class="comment">               &lt;&lt;sqrt(pdfmean_error_uncorr_sq)</span>
<a name="l00397"></a>00397 <span class="comment">               &lt;&lt;&quot; cov matrix (mean x p_E): &quot;&lt;&lt;2*(mAMP-mMEAN)*(1-mPE)*cov[P_E][MEAN]</span>
<a name="l00398"></a>00398 <span class="comment">               &lt;&lt;&quot; cov matrix (amp_E x p_E): &quot;&lt;&lt;2*(mAMP-mMEAN)*mPE*cov[P_E][AMP_E] </span>
<a name="l00399"></a>00399 <span class="comment">               &lt;&lt;&quot; cov matrix (mean x amp_E): &quot;&lt;&lt;2*(1-mPE)*mPE*cov[MEAN][AMP_E]</span>
<a name="l00400"></a>00400 <span class="comment">               &lt;&lt;endl;</span>
<a name="l00401"></a>00401 <span class="comment">               cov.Print(); */</span>
<a name="l00402"></a>00402     <span class="keywordflow">return</span> sqrt(pdfmean_error_uncorr_sq + (2*(mAMP-mMEAN)*(1-mPE)*cov[P_E][MEAN] 
<a name="l00403"></a>00403                                    + 2*(mAMP-mMEAN)*mPE*cov[P_E][AMP_E] 
<a name="l00404"></a>00404                                    + 2*(1-mPE)*mPE*cov[MEAN][AMP_E]));
<a name="l00405"></a>00405   
<a name="l00406"></a>00406   
<a name="l00407"></a>00407   
<a name="l00408"></a>00408   
<a name="l00409"></a>00409 }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="comment">/* double FitOverROI::pdfmean_error_corr(TFitResultPtr&amp; fitresult)</span>
<a name="l00412"></a>00412 <span class="comment">{</span>
<a name="l00413"></a>00413 <span class="comment">    TMatrixDSym cov = fitresult-&gt;GetCovarianceMatrix();</span>
<a name="l00414"></a>00414 <span class="comment">    const double* params = fitresult-&gt;GetParams();</span>
<a name="l00415"></a>00415 <span class="comment">    const double* errors = fitresult-&gt;GetErrors();</span>
<a name="l00416"></a>00416 <span class="comment">    double pdfmean_error_uncorr = sqrt(TMath::Power((mAMP-mMEAN)*errors[P_E],2)</span>
<a name="l00417"></a>00417 <span class="comment">                                       +TMath::Power((1-mPE)*errors[MEAN],2)</span>
<a name="l00418"></a>00418 <span class="comment">                                       +TMath::Power(mPE*errors[AMP_E],2));</span>
<a name="l00419"></a>00419 <span class="comment">    cout&lt;&lt;endl&lt;&lt;&quot;pdfmean uncorr:&quot;&lt;&lt;pdfmean_error_uncorr&lt;&lt;endl;</span>
<a name="l00420"></a>00420 <span class="comment">    cout&lt;&lt;&quot;correction: &quot;&lt;&lt;(sqrt(2/TMath::Pi())*mSIG*</span>
<a name="l00421"></a>00421 <span class="comment">         (1/(1 + TMath::Erf(mMEAN/(sqrt(2)*mSIG))) + </span>
<a name="l00422"></a>00422 <span class="comment">          mPE/(-2 + TMath::Erfc(mMEAN/(sqrt(2)*mSIG)))))/</span>
<a name="l00423"></a>00423 <span class="comment">        TMath::Power(TMath::E(),TMath::Power(mMEAN,2)/(2.*TMath::Power(mSIG,2)))&lt;&lt;endl;</span>
<a name="l00424"></a>00424 <span class="comment">    cout&lt;&lt;&quot;term 1: &quot;&lt;&lt;2*(mAMP-mMEAN)*(1-mPE)*cov[P_E][MEAN]&lt;&lt;&quot; term 2: &quot;&lt;&lt;2*(mAMP-mMEAN)*mPE*cov[P_E][AMP_E] &lt;&lt;&quot; term 3: &quot;&lt;&lt;2*(1-mPE)*mPE*cov[MEAN][AMP_E]&lt;&lt;endl;</span>
<a name="l00425"></a>00425 <span class="comment">    return pdfmean_error_uncorr + (2*(mAMP-mMEAN)*(1-mPE)*cov[P_E][MEAN] </span>
<a name="l00426"></a>00426 <span class="comment">                + 2*(mAMP-mMEAN)*mPE*cov[P_E][AMP_E] </span>
<a name="l00427"></a>00427 <span class="comment">                + 2*(1-mPE)*mPE*cov[MEAN][AMP_E]);</span>
<a name="l00428"></a>00428 <span class="comment"></span>
<a name="l00429"></a>00429 <span class="comment">} */</span>
<a name="l00430"></a>00430 <span class="comment">/* int ProcessSPEFile(const char* fname, Long_t roi = -1, int channel = -1, </span>
<a name="l00431"></a>00431 <span class="comment">   double emax = -1, bool force_old = false)</span>
<a name="l00432"></a>00432 <span class="comment">   {</span>
<a name="l00433"></a>00433 <span class="comment">   if(!gPad) new TCanvas;</span>
<a name="l00434"></a>00434 <span class="comment">   gPad-&gt;SetLogy();</span>
<a name="l00435"></a>00435 <span class="comment">   gPad-&gt;SetTitle(fname);</span>
<a name="l00436"></a>00436 <span class="comment">   static bool loaded = false;</span>
<a name="l00437"></a>00437 <span class="comment">   if(!loaded){</span>
<a name="l00438"></a>00438 <span class="comment">   gROOT-&gt;ProcessLine(&quot;.L lib/libDict.so&quot;);</span>
<a name="l00439"></a>00439 <span class="comment">   loaded = true;</span>
<a name="l00440"></a>00440 <span class="comment">   }</span>
<a name="l00441"></a>00441 <span class="comment"></span>
<a name="l00442"></a>00442 <span class="comment">   TFile* fin = new TFile(fname);</span>
<a name="l00443"></a>00443 <span class="comment">   if(!fin-&gt;IsOpen()){</span>
<a name="l00444"></a>00444 <span class="comment">   std::cerr&lt;&lt;&quot;Unable to open file &quot;&lt;&lt;fname&lt;&lt;std::endl;</span>
<a name="l00445"></a>00445 <span class="comment">   return 1;</span>
<a name="l00446"></a>00446 <span class="comment">   }</span>
<a name="l00447"></a>00447 <span class="comment"></span>
<a name="l00448"></a>00448 <span class="comment">   TTree* Events = (TTree*)(fin-&gt;Get(&quot;Events&quot;));</span>
<a name="l00449"></a>00449 <span class="comment">   if(!Events){</span>
<a name="l00450"></a>00450 <span class="comment">   std::cerr&lt;&lt;&quot;Unable to load Events tree from file &quot;&lt;&lt;fname&lt;&lt;std::endl;</span>
<a name="l00451"></a>00451 <span class="comment">   return 2;</span>
<a name="l00452"></a>00452 <span class="comment">   }</span>
<a name="l00453"></a>00453 <span class="comment">   TString data_source;</span>
<a name="l00454"></a>00454 <span class="comment">   if(roi == -1) data_source = &quot;channels[].pulses.integral&quot;;</span>
<a name="l00455"></a>00455 <span class="comment">   else data_source = TString(&quot;-channels[].regions[&quot;) + roi</span>
<a name="l00456"></a>00456 <span class="comment">   + TString(&quot;].integral&quot;);</span>
<a name="l00457"></a>00457 <span class="comment">   if( emax &lt; 0){</span>
<a name="l00458"></a>00458 <span class="comment">   Events-&gt;Draw(data_source+&quot; &gt;&gt; htemp&quot;,data_source+&quot; &gt; 0&quot;);</span>
<a name="l00459"></a>00459 <span class="comment">   TH1* htemp = (TH1*)(gROOT-&gt;FindObject(&quot;htemp&quot;));</span>
<a name="l00460"></a>00460 <span class="comment">   emax = htemp-&gt;GetMean()*HISTOGRAMWIDTH;</span>
<a name="l00461"></a>00461 <span class="comment">   }</span>
<a name="l00462"></a>00462 <span class="comment">        </span>
<a name="l00463"></a>00463 <span class="comment">   TCut min_en = (data_source+&quot; &gt; 0&quot;).Data();</span>
<a name="l00464"></a>00464 <span class="comment">   char chstring[100];</span>
<a name="l00465"></a>00465 <span class="comment">   sprintf(chstring,data_source+&quot; &lt; %.0f&quot;,emax);</span>
<a name="l00466"></a>00466 <span class="comment">   TCut max_en = chstring;</span>
<a name="l00467"></a>00467 <span class="comment">   sprintf(chstring,&quot;channels[].channel_id == %d&quot;,channel);</span>
<a name="l00468"></a>00468 <span class="comment">   TCut chan_cut = (channel == -1 ? &quot;&quot; : chstring);</span>
<a name="l00469"></a>00469 <span class="comment"></span>
<a name="l00470"></a>00470 <span class="comment">   TCut time_cut = (roi == -1 ? get_time_cut(Events, chan_cut) : &quot;&quot; );</span>
<a name="l00471"></a>00471 <span class="comment"></span>
<a name="l00472"></a>00472 <span class="comment">   TCut total_cut = min_en &amp;&amp; max_en &amp;&amp; time_cut &amp;&amp; chan_cut;</span>
<a name="l00473"></a>00473 <span class="comment">        </span>
<a name="l00474"></a>00474 <span class="comment">   Events-&gt;Draw(data_source+&quot; &gt;&gt; hspec&quot;,total_cut,&quot;e&quot;);</span>
<a name="l00475"></a>00475 <span class="comment">   TH1* hspec = (TH1*)(gROOT-&gt;FindObject(&quot;hspec&quot;));</span>
<a name="l00476"></a>00476 <span class="comment"></span>
<a name="l00477"></a>00477 <span class="comment"></span>
<a name="l00478"></a>00478 <span class="comment">   FitSPE(hspec, Events-&gt;GetEntries(&quot;channels[].baseline.found_baseline&quot;),</span>
<a name="l00479"></a>00479 <span class="comment">   force_old);</span>
<a name="l00480"></a>00480 <span class="comment"></span>
<a name="l00481"></a>00481 <span class="comment"></span>
<a name="l00482"></a>00482 <span class="comment">   return 0;</span>
<a name="l00483"></a>00483 <span class="comment">   } */</span>
<a name="l00484"></a>00484 
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 20 Jun 2014 for daqman by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
